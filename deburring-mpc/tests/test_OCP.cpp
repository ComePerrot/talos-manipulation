#define BOOST_TEST_NO_MAIN
#define BOOST_TEST_ALTERNATIVE_INIT_API

#include "common.hpp"
#include "deburring_mpc/ocp.hpp"
#include "factory/robot_designer.hpp"

using namespace boost::unit_test;

void testOCP() {
  // Robot Designer Factory
  deburring::unittest::RobotDesignerFactory factory;
  deburring::RobotDesigner pinWrapper = factory.createRobotDesigner();

  //  OCP
  std::string parameterFileOCP(PROJECT_SOURCE_DIR
                               "/tests/archive/"
                               "test_settings.yaml");
  deburring::OCPSettings ocpSettings = deburring::OCPSettings();
  ocpSettings.readParamsFromYamlFile(parameterFileOCP);
  deburring::OCP OCP = deburring::OCP(ocpSettings, pinWrapper);

  // Load data from serialized file
  std::vector<deburring::OCP_debugData>::size_type testCase = 0;
  std::vector<deburring::OCP_debugData> debugData =
      OCP.fetchFromFile(PROJECT_SOURCE_DIR
                        "/tests/archive/"
                        "data_OCP.txt");

  // Initialize OCP with the same initial state

  pinocchio::SE3 oMtarget;
  oMtarget.translation().x() = 0.6;
  oMtarget.translation().y() = 0.4;
  oMtarget.translation().z() = 1.1;

  // To have the gripper_left_fingertip_3_link in the right orientation we
  // need :
  //   90° around the y axis
  //   180° around the z axis
  double PI = boost::math::constants::pi<double>();
  double beta = -PI * 0.5;
  double gamma = PI;

  Eigen::Matrix3d rotationY;
  rotationY.row(0) << cos(beta), 0, -sin(beta);
  rotationY.row(1) << 0, 1, 0;
  rotationY.row(2) << sin(beta), 0, cos(beta);
  Eigen::Matrix3d rotationZ;
  rotationZ.row(0) << cos(gamma), sin(gamma), 0;
  rotationZ.row(1) << -sin(gamma), cos(gamma), 0;
  rotationZ.row(2) << 0, 0, 1;

  oMtarget.rotation() = rotationZ * rotationY;

  Eigen::VectorXd x_current = debugData[testCase].xi[0];

  OCP.initialize(x_current, oMtarget);
  // OCP.reprOCP(0);

  // Compare loaded data with the one generated by the OCP
  auto solver = OCP.get_solver();
  auto data = debugData[testCase];

  // State
  auto xs_OCP = solver->get_xs();
  auto xs_Data = data.xs;

  // Command
  auto us_OCP = solver->get_us();
  auto us_Data = data.us;

  // Riccati
  auto K_OCP = solver->get_K();
  auto K_Data = data.K;

  for (std::vector<Eigen::VectorXd>::size_type i = 0; i < xs_OCP.size(); i++) {
    BOOST_CHECK((xs_OCP[i] - xs_Data[i]).isZero(1e-10));
  }

  for (std::vector<Eigen::VectorXd>::size_type i = 0; i < us_OCP.size(); i++) {
    BOOST_CHECK((us_OCP[i] - us_Data[i]).isZero(1e-10));
  }

  for (std::vector<Eigen::VectorXd>::size_type i = 0; i < K_OCP.size(); i++) {
    BOOST_CHECK((K_OCP[i] - K_Data[i]).isZero(1e-8));
  }
}

void registerOCPUnitTest() {
  test_suite* ts = BOOST_TEST_SUITE("test_MPC");
  ts->add(BOOST_TEST_CASE(testOCP));
  framework::master_test_suite().add(ts);
}

bool init_function() {
  registerOCPUnitTest();
  return true;
}

int main(int argc, char** argv) {
  return ::boost::unit_test::unit_test_main(&init_function, argc, argv);
}